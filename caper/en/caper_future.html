<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>caper -- LALR(1) Parser Generator</title>
    <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"/>
    <style type="text/css">
      <!--
		  @import url("global.css");
		-->
    </style>
    <link rel="stylesheet" href="global.css" type="text/css"/>
  </head>
  <body>
    <div id="container">
      <div id="banner">
		<div id="header"><a href="caper.html">caper</a></div>
		<div id="subtext">Main > Future Works</div>
      </div>
      <div id="right">
		<div class="title">Main</div>
		<a href="caper.html">About Caper</a>
		<a href="caper_more.html">More About Caper</a>
		<a href="caper_inside.html">Inside Caper</a>
		<a href="caper_future.html">Future Works *</a>
		<a href="caper_license.html">License</a>
		<a href="caper_download.html">Download</a>
		<a href="caper_contact.html">Contact</a>
		<a href="caper_capella.html">Capella</a>
		<div class="title">Tutorials</div>
		<a href="caper_tutorial0.html">Tutorial0</a>
		<a href="caper_tutorial1.html">Tutorial1</a>
		<a href="caper_tutorial2.html">Tutorial2</a>
		<a href="caper_tutorial3.html">Tutorial3</a>
		<a href="caper_tutorial4.html">Tutorial4</a>
		<a href="caper_tutorial5.html">Tutorial5</a>
      </div>
      <div id="content">
		<h2><a name="i5"> </a> FUTURE WORKS... (or murmurs)</h2>

		<h3>Tried But Failed Things</h3>
		<ul  class="list1">
		  <li> parameterization of stack </li>
		  <ul  class="list3">
			<li> Like <code>Allocator::rebind</code>, I could realize it, but it was regarded as lack of simplicity.</li>
			<li> It is no delight to parameterize stack...</li>
		  </ul>
		</ul>

		<h3>Easy Things To Do</h3>

		<ul  class="list1">
		  <li> Perpetuation of Parser</li>
		  <ul  class="list3">
			<li> I cannot imagine the usage of it, but I can do it.</li>
		  </ul>
		  <li> Grammar / Visualization of Table / XML-nization</li>
		  <ul  class="list3">
			<li> Basically it's a variation of generator.</li>
			<li> I think it seems to be ended by throwing into boost.graph and outputing by graphviz etc.</li>
		  </ul>
		</ul>

		<h3>Difficult Things To Do</h3>
		<ul  class="list1">
		  <li> GLR parser</li>
		  <ul  class="list3">
			<li> Now might be the GLR parser age...( implemented by Elkhound, D Parser, bison-derived etc. )</li>
			<li> There seems to have difficult problems to solve.</li>
		  </ul>
		  <li> EBNF</li>
		  <ul  class="list3">
			<li> Not so difficult to do, ...</li>
			<li> There are problems on start up of semantic action... (I don't know how to treat lists...)</li>
			<li> Like this?</li>
		  </ul>
		</ul>

<pre>
struct SemanticActin {
	int DoAction1( const parser::Sequence&lt; T &gt;&amp; s ){}
	int DoAction2( const parser::Optional&lt; T &gt;&amp; s ){}
}
</pre>
		<ul  class="list3">
		  <ul  class="list3">
			<ul  class="list3">
			  <li> That I think so ... I cannot treat <code>(Foo Bar Baz)*</code>-like grammars.</li>
			</ul>
		  </ul>
		  <li> Scannar-Less Parser</li>
		  <ul  class="list3">
			<li> Usability is very good, but that has demerits...</li>
			<li> If scanner-less, token will be char.</li>
			<li> RegExp-to-Caper grammar converter required?</li>
			<li> Is it easy if I can use <code>boost::variant</code> in output parser?</li>
			<li> Is the table likely to be huge?</li>
			<li> Are there much separate merits?...</li>
			<li> I hope <code>boost::regex</code> had match actions or like that.</li>
			<li> The current <code>boost::regex</code> cannot determine which pattern was matched in O(1), so that is not suitable for scanner.</li>
			<li> Can I realize it by converting to token numbers by <code>replace_match</code> or like so?</li>
			<li> Is it OK that the scanner only uses spirit?</li>
			<li> Is it all right by <code>boost::tokenizer</code>?</li>
		  </ul>
		  <li> Auto generation of AST</li>
		  <ul  class="list3">
			<li> <code>boost::variant</code> was very good rather than I think.</li>
			<li> It seems that AST auto generation by using <code>boost::variant</code> may be realizeable.</li>
			<li> ... I think so, but it is not so easy, isn't it?</li>
		  </ul>
		</ul>

		<h3>Things To Improve</h3>
		<ul  class="list1">
		  <li> Dynamic parser engine</li>
		  <ul  class="list3">
			<li> The interface is not so good. I want to fix the bugs.</li>
		  </ul>
		</ul>
		
		<h2><a name="i7"> </a> Miscellaneous</h2>
		<p>
		  Your opinions and bug reports are wanted about...</p>
		<ul  class="list1">
		  <li> What compiler with what options causes what warnings.</li>
		  <li> This part of the source should use what of Boost.</li>
		  <li> I can make it clean and/or improve extendability.</li>
		  <li> I want to do something but I cannot. Can you help me?</li>
		  <li> I cannot understand the meaning of this error message.</li>
		  <li> This error message is wrong in English</li>
		  <li> This component name is not intuitive.</li>
		</ul>
		<p>
		  Don't hesitate to email me. Anonymous OK.</p>
      </div>

      <div id="footer">Content &copy; 2006-2008 Naoyuki HIRAYAMA</div>
      <!-- Designed by and (c) Copyright 2005 Shady-Sock ( http://www.oswd.org/userinfo.phtml?user=Shady-Sock ). Email ( sani.sarip@gmail.com ). Do not remove this. -->
	</div>
  </body>
</html>
