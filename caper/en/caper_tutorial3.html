<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>caper -- LALR(1) Parser Generator</title>
    <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"/>
    <style type="text/css">
	  <!--
		  @import url("global.css");
		-->
    </style>
    <link rel="stylesheet" href="global.css" type="text/css"/>
  </head>
  <body>
    <div id="container">
	  <div id="banner">
		<div id="header"><a href="caper.html">caper</a></div>
		<div id="subtext">Tutorials > Tutorial3</div>
	  </div>
	  <div id="right">
		<div class="title">Main</div>
		<a href="caper.html">About Caper</a>
		<a href="caper_more.html">More About Caper</a>
		<a href="caper_inside.html">Inside Caper</a>
		<a href="caper_future.html">Future Works</a>
		<a href="caper_license.html">License</a>
		<a href="caper_download.html">Download</a>
		<a href="caper_contact.html">Contact</a>
		<a href="caper_capella.html">Capella</a>
		<div class="title">Tutorials</div>
		<a href="caper_tutorial0.html">Tutorial0</a>
		<a href="caper_tutorial1.html">Tutorial1</a>
		<a href="caper_tutorial2.html">Tutorial2</a>
		<a href="caper_tutorial3.html">Tutorial3 *</a>
		<a href="caper_tutorial4.html">Tutorial4</a>
		<a href="caper_tutorial5.html">Tutorial5</a>
	  </div>
	  <div id="content">
		<h1><a name="i0"> </a> tutorial 3 -- Calculator &alpha;</h1>
		<p>This time is the sample of calcucator.</p>

		<h2><a name="i1"> </a> The Grammar File</h2>
<pre>
%token Number&lt;int&gt; Add Sub Mul Div;
%namespace calc;
%dont_use_stl;

Expr&lt;int&gt; : [Identity] Term(0)
          | [MakeAdd] Expr(0) Add Term(1)
          | [MakeSub] Expr(0) Sub Term(1)
          ;

Term&lt;int&gt; : [Identity] Number(0)
          | [MakeMul] Term(0) Mul Number(1)
          | [MakeDiv] Term(0) Div Number(1)
          ;
</pre>
		  <p>If you experienced usage of BNF, you can easily understand almost all.
		  As described above, the element not followed by "(digit)" is not used in the semantic action.</p>

		  <h2><a name="i2"> </a> The Handling File</h2>
<pre>
#include &quot;calc0.hpp&quot;
#include &lt;iostream&gt;

class unexpected_char : public std::exception {};

template &lt; class It &gt;
class scanner {
public:
        typedef int char_type;

public:
        scanner( It b, It e ) : b_(b), e_(e), c_(b), unget_(EOF) { }

        calc::Token get( int&amp; v )
        {
                int c;
                do {
                        c = getc();
                } while( isspace( c ) );

                // symbols
                switch( c ) {
                case '+': return calc::token_Add;
                case '-': return calc::token_Sub;
                case '*': return calc::token_Mul;
                case '/': return calc::token_Div;
                case EOF: return calc::token_eof;
                }

                // integers
                if( isdigit( c ) ) {
                        int n = 0;
                        while( c != EOF &amp;&amp; isdigit( c ) ) {
                                n *= 10;
                                n += c - '0';
                                c = getc();
                        }
                        ungetc( c );
                        v = n;
                        return calc::token_Number;
                }


                std::cerr &lt;&lt; char(c) &lt;&lt; std::endl;
                throw unexpected_char();
        }

private:
        char_type getc()
        {
                int c;
                if( unget_ != EOF ) {
                        c = unget_;
                        unget_ = EOF;
                } else if( c_ == e_ ) {
                        c = EOF; 
                } else {
                        c = *c_++;
                }
                return c;
        }

        void ungetc( char_type c )
        {
                if( c != EOF ) {
                        unget_ = c;
                }
        }

private:
        It              b_;
        It              e_;
        It              c_;
        char_type       unget_;

};

struct SemanticAction {
        void syntax_error(){}
        void stack_overflow(){}
        void downcast( int&amp; x, int y ) { x = y; }
        void upcast( int&amp; x, int y ) { x = y; }

        int Identity( int n ) { return n; }
        int MakeAdd( int x, int y )
        {
                std::cerr &lt;&lt; &quot;expr &quot; &lt;&lt; x &lt;&lt; &quot; + &quot; &lt;&lt; y &lt;&lt; std::endl;
                return x + y ; 
        }
        int MakeSub( int x, int y )
        {
                std::cerr &lt;&lt; &quot;expr &quot; &lt;&lt; x &lt;&lt; &quot; - &quot; &lt;&lt; y &lt;&lt; std::endl;
                return x - y ; 
        }
        int MakeMul( int x, int y )
        {
                std::cerr &lt;&lt; &quot;expr &quot; &lt;&lt; x &lt;&lt; &quot; * &quot; &lt;&lt; y &lt;&lt; std::endl;
                return x * y ;
        }
        int MakeDiv( int x, int y )
        {
                std::cerr &lt;&lt; &quot;expr &quot; &lt;&lt; x &lt;&lt; &quot; / &quot; &lt;&lt; y &lt;&lt; std::endl;
                return x / y ;
        }
};

int main( int, char** )
{
        // The scanner
        typedef std::istreambuf_iterator&lt;char&gt; is_iterator;
        is_iterator b( std::cin );
        is_iterator e;
        scanner&lt; is_iterator &gt; s( b, e );

        SemanticAction sa;

        calc::Parser&lt; int, SemanticAction &gt; parser( sa );

        calc::Token token;
        for(;;) {
                int v;
                token = s.get( v );
                if( parser.post( token, v ) ) { break; }
        }

        int v;
        if( parser.accept( v ) ) {
                std::cerr &lt;&lt; &quot;accpeted\n&quot;;
                std::cerr &lt;&lt; v &lt;&lt; std::endl;
        }

        return 0;
}
</pre>

		<p>This time, for a scanner was necessary, so I prepared a handwritten scanner.
		There is no difficult stuffs. Read the source carefully.
		If handwriting is troublesome for you, you can use <code>boost::regex</code> etc.</p>
		<p>At semantic actions, there is no new type items.</p>
		<p>The <code>main</code> function introduced new item as below:</p>

		<h4><a name="i3"> </a> The return value of <code>parser.post</code></h4>
		<p>Returns <code>true</code> when the whole was accepted or error was detected; otherwise returns <code>false</code>.</p>
		<h4><a name="i4"> </a> The return value of <code>parser.accept</code></h4>
		<p><code>parser.accept</code> is valid only after <code>parser.post</code> returned <code>true</code>.
		If error occurs, <code>v</code> becomes an indefinite value and the function returns <code>false</code>.
		Otherwise it is successful, <code>v</code> is assigned the value of the left side of the root grammar, and
		the function returns <code>true</code>.</p>
		<p>If you experienced yacc etc., there is no difficult thing.</p>

		<h2><a name="i5"> </a> Execution</h2>
<pre>
% ./calc0
8+3*7
^D
expr 3 * 7
expr 8 + 21
accepted
29
</pre>

      </div>

      <div id="footer">Content &copy; 2006-2008 Naoyuki HIRAYAMA</div>
      <!-- Designed by and (c) Copyright 2005 Shady-Sock ( http://www.oswd.org/userinfo.phtml?user=Shady-Sock ). Email ( sani.sarip@gmail.com ). Do not remove this. -->
    </div>
  </body>
</html>
